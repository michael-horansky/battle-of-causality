# -----------------------------------------------------------------------------
# --------------------------- class Abstract_Output ---------------------------
# -----------------------------------------------------------------------------
# An instance is created by GM and fed into any Renderer-type class instance
# Encodes both static and interactive elements of the game state
#
# NOTE: The value of Abstract_Output as generated by a loaded instance of
# Gamemaster is context-dependent. E.g. the list of stones which can be
# commanded depends on the player who opened the game. This is unlike the
# Gamemaster instance, which is context-independent, and always built the same.

import utils.constants as constants
import utils.functions as functions

from game_logic.class_Flag import Flag

class Abstract_Output():

    process_list = [
            "flags",        # State of board after naive flagh execution
            "pushes",       # State of board after sokoban pushes, opposition, and impasses
            "destructions", # State of board after captures and explosions
            "tagscreens",   # State of board after tagscreens
            "canon"         # State of board after stone and board actions (e.g. attacks)
        ]

    command_keywords = [
            "stone_ID",
            "type",
            "t",
            "x",
            "y",
            "a",
            "target_t",
            "target_x",
            "target_y",
            "target_a",
            "swap_effect",
            "choice_keyword"
        ]

    def shift_process(cur_process, delta_index):
        return Abstract_Output.process_list[(Abstract_Output.process_list.index(cur_process) + delta_index) % len(Abstract_Output.process_list)]

    def __init__(self):
        # ------------------------ General properties -------------------------
        self.board_static = None
        self.t_dim = None
        self.x_dim = None
        self.y_dim = None

        self.factions = []
        self.faction_armies = [] # ["faction"] = [stone_ID list]
        self.stone_properties = {} # ["stone_ID"] = {"allegiance", "stone_type", "orientable", "opposable"}
        self.reverse_causality_flags = {"causes" : [], "effects" : []} # List of keys of reverse_causality_flag_properties
        self.reverse_causality_flag_properties = {} # ["flag_ID"] = {"t", "x", "y", "flag_type", "stone_ID", "target_effect"} for flag_IDs important to Scenarios

        # Command input properties
        self.did_player_finish_turn = False
        self.stones_to_be_commanded = [] # list of stone IDs
        self.available_commands = {} # [stone_ID] = available_commands object
        # ----------------------- Roundwise properties ------------------------
        # These variables always have the first axis [round number], and
        # describe the state of the game in the canonised version of the round,
        # or (for the last value) the state of the game as current_turn begins.
        self.stone_trajectories = [] # [round_number][t]["process"][stone_ID] = state, where "process" specifies which part of the round this state describes
        self.stone_endpoints = [] #[round_number][stone_ID] = {"start" : desc, "end" : desc} or None

        self.stone_actions = [] # [round_number][t][action index] = [stone_type, action_type, stone_x, stone_y, param1, param2...]

        self.time_jumps = [] # [round_number]["t"]["x"]["y"]["used"/"unused"] = "TJI"/"TJO"/"conflict" if present
        self.scenarios = [] # [round_number] = {{setup activity map}, {effect activity map}, {effect cause map}, {stone inheritance}, {removed setup stones}}
        self.effects = [] # [round_number] [list of flag_IDs of ante-effects added on that round. These effects will be inactive in the canonised version, but their causes are already active.]
        self.causes = [] # [round_number] [list of flag_IDs of retro-causes added on that round. These effects will be activated in the canonised version, but their effects are inactive.]
        self.activated_buffered_causes = [] # [round_number] = list of retro-causes added that round which were activated in the precanonised scenario

        self.current_turn = None


    # -------------------------------------------------------------------------
    # ---------------------- General property management ----------------------
    # -------------------------------------------------------------------------

    def set_board_dimensions(self, t_dim, x_dim, y_dim):
        self.t_dim = t_dim
        self.x_dim = x_dim
        self.y_dim = y_dim

    def set_board_static(self, board_static):
        self.board_static = board_static # [x][y] = square string rep

    def record_faction_armies(self, factions, faction_armies, gm_stones):
        self.factions = factions
        self.faction_armies = faction_armies
        for stone_ID, stone_object in gm_stones.items():
            self.stone_properties[stone_ID] = {
                    "allegiance" : stone_object.player_faction,
                    "stone_type" : stone_object.stone_type,
                    "orientable" : stone_object.orientable,
                    "opposable" : stone_object.opposable
                }

    def set_current_turn(self, current_turn):
        self.current_turn = current_turn


    # -------------------------------------------------------------------------
    # --------------------- Roundwise property management ---------------------
    # -------------------------------------------------------------------------

    # --------------- Resets at the beginning of execute_moves ----------------

    def reset_round(self, round_n):
        # Prepares all variables to contain round_n key
        if len(self.stone_trajectories) > round_n:
            # key exists
            self.stone_trajectories[round_n] = []
            for t in range(self.t_dim):
                self.stone_trajectories[round_n].append({})
                for process_key in Abstract_Output.process_list:
                    self.stone_trajectories[round_n][t][process_key] = {}
        else:
            # We keep appending empty turns until key exists
            while(len(self.stone_trajectories) <= round_n):
                self.stone_trajectories.append([])
                for t in range(self.t_dim):
                    self.stone_trajectories[-1].append({})
                    for process_key in Abstract_Output.process_list:
                        self.stone_trajectories[-1][t][process_key] = {}

        if len(self.stone_endpoints) > round_n:
            # key exists
            self.stone_endpoints[round_n] = {}
        else:
            while(len(self.stone_endpoints) <= round_n):
                self.stone_endpoints.append({})

        if len(self.stone_actions) > round_n:
            # key exists
            self.stone_actions[round_n] = []
            for t in range(self.t_dim):
                self.stone_actions[round_n].append([])
        else:
            # We keep appending empty turns until key exists
            while(len(self.stone_actions) <= round_n):
                self.stone_actions.append([])
                for t in range(self.t_dim):
                    self.stone_actions[-1].append([])

        if len(self.time_jumps) > round_n:
            # key exists
            self.time_jumps[round_n] = {}
        else:
            # We keep appending empty turns until key exists
            while(len(self.time_jumps) <= round_n):
                self.time_jumps.append({})

        if len(self.scenarios) > round_n:
            # key exists
            self.scenarios[round_n] = {}
        else:
            # We keep appending empty turns until key exists
            while(len(self.scenarios) <= round_n):
                self.scenarios.append({})

        if len(self.effects) > round_n:
            # key exists
            self.effects[round_n] = []
        else:
            # We keep appending empty turns until key exists
            while(len(self.effects) <= round_n):
                self.effects.append([])

        if len(self.causes) > round_n:
            # key exists
            self.causes[round_n] = []
        else:
            # We keep appending empty turns until key exists
            while(len(self.causes) <= round_n):
                self.causes.append([])

        if len(self.activated_buffered_causes) > round_n:
            # key exists
            self.activated_buffered_causes[round_n] = []
        else:
            # We keep appending empty turns until key exists
            while(len(self.activated_buffered_causes) <= round_n):
                self.activated_buffered_causes.append([])

    # --------------------------- Value assignment ----------------------------

    def add_empty_trajectory(self, round_n, stone_ID):
        for t in range(self.t_dim):
            for process_key in Abstract_Output.process_list:
                self.stone_trajectories[round_n][t][process_key][stone_ID] = None
        self.stone_endpoints[round_n][stone_ID] = None

    def add_stone_endpoint(self, round_n, stone_ID, endpoint_key, endpoint_event, endpoint_pos):
        if self.stone_endpoints[round_n][stone_ID] is None:
            self.stone_endpoints[round_n][stone_ID] = {endpoint_key : {"event" : endpoint_event, "t" : endpoint_pos.t, "x" : endpoint_pos.x, "y" : endpoint_pos.y}}
        else:
            self.stone_endpoints[round_n][stone_ID][endpoint_key] = {"event" : endpoint_event, "t" : endpoint_pos.t, "x" : endpoint_pos.x, "y" : endpoint_pos.y}

    def add_stone_action(self, round_n, t, action_array):
        self.stone_actions[round_n][t].append(action_array.copy())

    def add_time_jump(self, round_n, t, x, y, is_used, time_jump_type):
        if t not in self.time_jumps[round_n].keys():
            self.time_jumps[round_n][t] = {}
        if x not in self.time_jumps[round_n][t].keys():
            self.time_jumps[round_n][t][x] = {}
        if y not in self.time_jumps[round_n][t][x].keys():
            self.time_jumps[round_n][t][x][y] = {}
        if is_used not in self.time_jumps[round_n][t][x][y].keys():
            self.time_jumps[round_n][t][x][y][is_used] = time_jump_type
        elif self.time_jumps[round_n][t][x][y][is_used] not in [time_jump_type, "conflict"]:
            self.time_jumps[round_n][t][x][y][is_used] = "conflict"

    def add_activated_buffered_cause(self, round_n, buffered_cause_ID):
        self.activated_buffered_causes[round_n].append(buffered_cause_ID)

    def add_scenario(self, round_n, scenario_instance, flags, causes_added_this_round, effects_added_this_round):
        # NOTE: The rounds represented in Abstract_Output (sans the last one)
        # governed by the scenarios for the NEXT round, MINUS the ante-effects
        # added in this round. The only way the rule of dogma manifests in the
        # canonised version is that the buffered causes are still active.
        self.scenarios[round_n]["effect_activity_map"] = scenario_instance.effect_activity_map
        self.scenarios[round_n]["effect_cause_map"] = scenario_instance.effect_cause_map
        self.scenarios[round_n]["setup_activity_map"] = scenario_instance.setup_activity_map
        self.scenarios[round_n]["stone_inheritance"] = scenario_instance.stone_inheritance
        self.scenarios[round_n]["removed_setup_stones"] = scenario_instance.removed_setup_stones
        # all the effects and causes present in effect_cause map which are not
        # present in reverse_causality_flag_properties were added this round!
        self.effects[round_n] = effects_added_this_round
        self.causes[round_n] = causes_added_this_round
        for cause_ID in causes_added_this_round:
            self.reverse_causality_flag_properties[cause_ID] = {
                    "t" : flags[cause_ID].pos.t,
                    "x" : flags[cause_ID].pos.x,
                    "y" : flags[cause_ID].pos.y,
                    "flag_type" : flags[cause_ID].flag_type,
                    "stone_ID" : flags[cause_ID].stone_ID,
                    "target_effect" : flags[cause_ID].effect
                }
            #self.reverse_causality_flags["causes"].append(cause_ID)
        for effect_ID in effects_added_this_round:
            self.reverse_causality_flag_properties[effect_ID] = {
                    "t" : flags[effect_ID].pos.t + 1, # Since effects are always shifted by one timeslice
                    "x" : flags[effect_ID].pos.x,
                    "y" : flags[effect_ID].pos.y,
                    "flag_type" : flags[effect_ID].flag_type,
                    "stone_ID" : flags[effect_ID].stone_ID,
                    "target_effect" : None
                }
            #self.reverse_causality_flags["effects"].append(effect_ID)



